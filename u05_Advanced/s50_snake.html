<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <canvas id="canvas" width="500px" height="500px" style="border: 1px solid black;" tabindex="1" autofocus></canvas>
  <p id="coordinateValues">Coordinates - x: 0, y: 0</p>
  <script>
    //The basic template of this file was provided in class as a starting point, which included the following functions: drawCircle, isPointInCircle, isCircleInCircle, isRectInRect, didRectangleCircleCollide, kbInput, keyHandler, and getCursorPosition
    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")

    let snakeSpeed = 250
    let durationSnakeGrowsAtStart = 1.5
    let durationOfPauseOnEatingApple = .3
    let gameOver = false

    let snakeHead = {
      xPos: 250,
      yPos: 250,
      width: 10,
      height: 10,
      xVel: snakeSpeed,
      yVel: 0,
    }

    let apple = {
      xPos: 100,
      yPos: 150,
      width: 20,
      height: 20,
    }

    let bodies = []

    function bodyFactory(xPos, yPos, width, height){
      return {
        xPos: xPos,
        yPos: yPos,
        width: width,
        height: height,
      }
    }

    function getSnakeHeadSides(snakeHead){
      return {
        top: {
          xPos: snakeHead.xPos,
          yPos: snakeHead.yPos - .001,
          width: snakeHead.width,
          height: .0001,
        },
        bottom: {
          xPos: snakeHead.xPos,
          yPos: snakeHead.yPos + snakeHead.height + .001,
          width: snakeHead.width,
          height: .0001,
        },
        left: {
          xPos: snakeHead.xPos - .001,
          yPos: snakeHead.yPos,
          width: .0001,
          height: snakeHead.height,
        },
        right: {
          xPos: snakeHead.xPos + snakeHead.width + .001,
          yPos: snakeHead.yPos,
          width: .0001,
          height: snakeHead.height,
        }
      }
    }

    function appleCollidingWithBody(apple,bodies){
      for(let body of bodies){
        if(isRectInRect(apple,body)){
          return true
        }
      }
      return false
    }


    let totalTimeElapsed = 0
    let prevTimeStamp = 0
    window.requestAnimationFrame(gameLoop)
    function gameLoop(currentTimeStamp) {
      let timeElapsed = (currentTimeStamp - prevTimeStamp) / 1000
      totalTimeElapsed+=timeElapsed

      prevTimeStamp = currentTimeStamp
      ctx.clearRect(0, 0, 500, 500)

      snakeHead.xPos = snakeHead.xPos + snakeHead.xVel*timeElapsed
      snakeHead.yPos = snakeHead.yPos + snakeHead.yVel*timeElapsed

      bodies.push(bodyFactory(snakeHead.xPos, snakeHead.yPos, snakeHead.width, snakeHead.height))
      if(totalTimeElapsed>durationSnakeGrowsAtStart){
        console.log("here")
        bodies.shift()
      }


      //Collision
      if(isRectInRect(apple, snakeHead)){
        totalTimeElapsed=durationSnakeGrowsAtStart-durationOfPauseOnEatingApple
        apple.xPos = Math.random()*400 + 50
        apple.yPos = Math.random()*400 + 50
        while(appleCollidingWithBody(apple, bodies)){
          apple.xPos = Math.random()*400 + 50
          apple.yPos = Math.random()*400 + 50
        }

      }



      let snakeHeadSides = getSnakeHeadSides(snakeHead)
      for(let body of bodies){
        if(snakeHead.yVel>0){ //going DOWN
          if(isRectInRect(snakeHeadSides.bottom,body)) gameOver = true
        }else if(snakeHead.yVel<0){ //going UP
          if(isRectInRect(snakeHeadSides.top,body)) gameOver = true
        }else if(snakeHead.xVel>0){ //going RIGHT
          if(isRectInRect(snakeHeadSides.right,body)) gameOver = true
        }else if(snakeHead.xVel<0){ //going LEFT
          if(isRectInRect(snakeHeadSides.left,body)) gameOver = true
        }
      }

      //Keyboard Input
      if(kbInput.up.isPressed && snakeHead.yVel === 0){
        snakeHead.yVel = -1*snakeSpeed
        snakeHead.xVel = 0
      }

      if(kbInput.down.isPressed && snakeHead.yVel === 0){
        snakeHead.yVel = snakeSpeed
        snakeHead.xVel = 0
      }

      if(kbInput.right.isPressed && snakeHead.xVel === 0){
        snakeHead.yVel = 0
        snakeHead.xVel = snakeSpeed
      }

      if(kbInput.left.isPressed && snakeHead.xVel === 0){
        snakeHead.yVel = 0
        snakeHead.xVel = -1*snakeSpeed
      }


      /*
        Drawing
       */

      //snake
      ctx.fillStyle = "black"
      ctx.fillRect(snakeHead.xPos, snakeHead.yPos, snakeHead.width, snakeHead.height)
      for(let body of bodies){
        ctx.fillRect(body.xPos, body.yPos, body.width, body.height)
      }

      //apple
      ctx.fillStyle = "red"
      ctx.fillRect(apple.xPos, apple.yPos, apple.width, apple.height)

      //
      if(gameOver){
        ctx.fillText("Game Over", 250, 250)
        //gameOver = false
      }



      window.requestAnimationFrame(gameLoop)
    }

    function drawCircle(circle){
      ctx.beginPath()
      ctx.arc(circle.xPos, circle.yPos, circle.radius, 0, Math.PI*2)
      ctx.fill()
      ctx.closePath()
    }

    function isPointInCircle(xPoint, yPoint, circle){
      if(Math.sqrt(  Math.pow(circle.xPos - xPoint, 2)  + Math.pow(circle.yPos - yPoint, 2) )  < circle.radius){
        return true
      }else{
        return false
      }
    }

    function isCircleInCircle(circle1, circle2){
      let distanceBetweenCircles = Math.sqrt(Math.pow(circle1.xPos - circle2.xPos, 2 ) + Math.pow(circle1.yPos - circle2.yPos, 2))
      if(distanceBetweenCircles > circle1.radius + circle2.radius){
        return false
      }else{
        return true
      }
    }


    function isRectInRect(rect1, rect2){ //https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
      if (rect1.xPos < rect2.xPos + rect2.width &&
              rect1.xPos + rect1.width > rect2.xPos &&
              rect1.yPos < rect2.yPos + rect2.height &&
              rect1.yPos + rect1.height > rect2.yPos) {
        return true
      }else{
        return false
      }
    }

    function didRectangleCircleCollide(rect, circle){ //https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle
      let rect_x = rect.xPos
      let rect_y = rect.yPos
      let rect_w = rect.width
      let rect_h = rect.height
      let circle_x = circle.xPos
      let circle_y = circle.yPos
      let circle_r = circle.radius
      let distX = Math.abs(circle_x - rect_x-rect_w/2);
      let distY = Math.abs(circle_y - rect_y-rect_h/2);

      if (distX > (rect_w/2 + circle_r)) { return false; }
      if (distY > (rect_h/2 + circle_r)) { return false; }

      if (distX <= (rect_w/2)) { return true; }
      if (distY <= (rect_h/2)) { return true; }

      let dx=distX-rect_w/2;
      let dy=distY-rect_h/2;
      return (dx*dx+dy*dy<=(circle_r*circle_r));
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Keyboard Input
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    canvas.addEventListener('keydown', keyHandler)
    canvas.addEventListener('keyup', keyHandler)

    let kbInput = {
      left : {
        value : "ArrowLeft",
        isPressed: false,
      },
      right : {
        value : "ArrowRight",
        isPressed: false,
      },
      down : {
        value : "ArrowDown",
        isPressed: false,
      },
      up : {
        value : "ArrowUp",
        isPressed: false,
      },
    }

    function keyHandler(event) {
      event.preventDefault() //prevents the keys that you press from performing their default action in your internet browser (for ex: when you press the down arrow key, the browser window will not scroll down)
      let type = event.type
      let isPressed = false
      if(type==="keydown"){
        isPressed = true
      }
      if(event.key===kbInput.left.value){
        kbInput.left.isPressed = isPressed
      }
      if(event.key===kbInput.right.value){
        kbInput.right.isPressed = isPressed
      }
      if(event.key===kbInput.up.value){
        kbInput.up.isPressed = isPressed
      }
      if(event.key===kbInput.down.value){
        kbInput.down.isPressed = isPressed
      }
    }

    //Mouse Input Stuff
    let xCoord = 0
    let yCoord = 0
    function getCursorPosition(canvas, event) {
      const rect = canvas.getBoundingClientRect()
      xCoord = event.clientX - rect.left
      yCoord = event.clientY - rect.top
      document.getElementById("coordinateValues").innerHTML = "Coordinates - x: "+xCoord+", y: "+yCoord
    }

    canvas.addEventListener('mousemove', function(e) { getCursorPosition(canvas, e)})


    //addEventListener('click', (event) => {});

    onclick = (event) => { console.log("clicking") }

  </script>
</head>
<body></body>
</html>